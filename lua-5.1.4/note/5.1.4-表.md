# 5.1.4 表

## 1. 数据结构

```c
/*
** Tables
*/

typedef union TKey {
  struct {
    TValuefields;
    struct Node *next;  /* for chaining */
  } nk;
  TValue tvk;
} TKey;


typedef struct Node {
  TValue i_val;
  TKey i_key;
} Node;


typedef struct Table {
  CommonHeader;
  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */ 
  lu_byte lsizenode;  /* log2 of size of `node' array */
  struct Table *metatable;
  TValue *array;  /* array part */
  Node *node;
  Node *lastfree;  /* any free position is before this position */
  GCObject *gclist;
  int sizearray;  /* size of `array' array */
} Table;
} Table;
```

- **CommonHeader**：通用头

- **lu_byte flags**：byte类型的数据，表示表中提供了哪些元方法。

- **lu_bute lsizenode**：该表中以2为底的散列表大小的对数值。

- **struct Table *metatable**：存放该表的元表。

- **TValue *array**：指向数组部分的指针。

- **Node *node**：指向该表的散列桶数组的起始位置的指针。

- **Node *lastfree**：指向该表的散列桶数组的最后位置的指针。

- **GCObject *gclist**：GC相关的链表

- **int sizearray**：数组部分的大小。

**lsizenode**表示散列表部分的大小一定是以2的幂。

![ltable](https://raw.githubusercontent.com/XieShou/LuaSourceCodeNote/master/lua-5.1.4/note/images/ltable.jpg)

## 2. 操作算法

### 2.1 查找算法

> 如果输入的key是一个正整数，并且它的值2 >0 && <= 数组大小
> 
>         尝试在数组部分查找
> 
> 否则尝试在散列表部分查找
> 
>         计算出该key的散列值，根据此散列值访问Node数组得到散列桶所在的位置
> 
>         遍历改散列桶下的所有链表元素，知道找到该key为止

看如下案例：

```lua
local t = {}
t[1] = 0          --在数组部分
t[100] = 0        --在散列表部分
```

### 2.2 新增元素

**mainposition**：散列表部分的数组，先计算数据的key所在的桶数组位置，这个位置称为mainposition。相同mainposition的数据以链表形式组织。
