# 5.1.4 表

## 1. 数据结构

```c
/*
** Tables
*/

typedef union TKey {
  struct {
    TValuefields;
    struct Node *next;  /* for chaining */
  } nk;
  TValue tvk;
} TKey;


typedef struct Node {
  TValue i_val;
  TKey i_key;
} Node;


typedef struct Table {
  CommonHeader;
  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */ 
  lu_byte lsizenode;  /* log2 of size of `node' array */
  struct Table *metatable;
  TValue *array;  /* array part */
  Node *node;
  Node *lastfree;  /* any free position is before this position */
  GCObject *gclist;
  int sizearray;  /* size of `array' array */
} Table;
} Table;
```

- **CommonHeader**：通用头

- **lu_byte flags**：byte类型的数据，表示表中提供了哪些元方法。

- **lu_bute lsizenode**：该表中以2为底的散列表大小的对数值。

- **struct Table *metatable**：存放该表的元表。

- **TValue *array**：指向数组部分的指针。

- **Node *node**：指向该表的散列桶数组的起始位置的指针。

- **Node *lastfree**：指向该表的散列桶数组的最后位置的指针。

- **GCObject *gclist**：GC相关的链表

- **int sizearray**：数组部分的大小。

**lsizenode**表示散列表部分的大小一定是以2的幂。

<img src="https://raw.githubusercontent.com/XieShou/LuaSourceCodeNote/master/lua-5.1.4/note/images/ltable.jpg" title="" alt="ltable" width="514">

## 2. 操作算法

### 2.1 查找算法

> 如果输入的key是一个正整数，并且它的值2 >0 && <= 数组大小
> 
>         尝试在数组部分查找
> 
> 否则尝试在散列表部分查找
> 
>         计算出该key的散列值，根据此散列值访问Node数组得到散列桶所在的位置
> 
>         遍历改散列桶下的所有链表元素，知道找到该key为止

看如下案例：

```lua
local t = {}
t[1] = 0          --在数组部分
t[100] = 0        --在散列表部分
```

### 2.2 新增元素

**mainposition**：散列表部分的数组，先计算数据的key所在的桶数组位置，这个位置称为mainposition。相同mainposition的数据以链表形式组织。

针对散列表部分的操作包括`luaH_set`、`luaH_setnum`、`luaH_setstr`三个函数，他们的实际行为并不在其函数内部对key所对应的数据进行添加或者修改，而是返回根据该key查找到的TValue指针，由外部的使用者来进行实际的替换操作。

当找不到key时，这几个API最终都会调用内部的`newkey`函数分配一个新的key来返回：

>  **ltable.c 392行**：
> 
> ```c
> static TValue *newkey (lua_State *L, Table *t, const TValue *key) { ... }
> ```

其中涉及到对表空间的重新分配的情况。入口函数是`rehash`：

> **ltable.c 333行**：
> 
> ```c
> /*
> ** 向hash表中插入一个key；
> ** 首先检查是否key的mainposition是空的。
> ** 1. 如果是空的，直接将key赋值并且返回Node 的TValue指针就可以了。
> ** 2. 如果不是，检查Node是否已经在该mainposition。
> ** 2.1 如果不在，说明该mainposition已经有其他数据了，需要重新分配空间给这个新的key。
> ** 移动Node到一个空的位置并且在该mainposition桶中放入一个新的key
> ** 2.2 如果节点已经在该mainposition，新的key去一个空的位置
> */
> static void rehash (lua_State *L, Table *t, const TValue *ek) { ... }
> ```
